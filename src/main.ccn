start phase RootPhase {
    info = "Denotes the entry point of your compiler",

    actions {
        pass SPdoScanParse;
        Demo;
        print;
    }
};

traversal Print {
    uid = PRT
};

phase Demo {
    actions {
        traversal RenameIdentifiers {
            uid = RI,
            nodes = { Var, VarLet }
        };

        traversal SumInts {
            uid = SI,
            nodes = { Stmts, Num },
            travdata {
                int sum
            }
        };

        traversal OptSubstraction {
            uid = OS,
            nodes = { Binop }
        };
    }
};

/*** AST ***/

enum MonOpType {
    prefix = MO,
    values {
        not, neg
    }
};

enum BinOpType {
    prefix = BO,
    values {
        add, sub, mul, div, mod, lt, le, gt, ge, eq, ne,
        and, or
    }
};

enum ArrayType {
    prefix = AT,
    values {
      float, bool, int
    }
};

enum IfType {
    prefix = IFT,
    values {
        if, elseif, else
    }
};

nodeset DefNodes = {Num, Float, Bool, Vector, Matrix};

enum Declaration {
    prefix = Dec,
    values {
        Export, Extern, Local
    }
};

nodeset FunctionType = DefNodes | {Void};

nodeset Expr = {Num, Float, Bool, Binop, Var, Call};

nodeset Stmt = {Assign};
 
// Nodes you want to be able to link to from your symbol table.
nodeset Link = Expr | Stmt;

root node Program {
    children {
        Stmts stmts { constructor, mandatory }
    }
};

node Exprs {
    children {
        Expr expr { constructor, mandatory },
        Exprs next { constructor }
    }
};

node Stmts {
    children {
        Stmt stmt { constructor, mandatory },
        Stmts next { constructor }
    }
};

node Parameter {
    attributes {
       DefNodes type,
       Var name 
    }
};

node Parameters {
    children {
        Parameter parameter { constructor, mandatory },
        Parameters next
    }
};

//

node FunctionBody {
    children {
        LocalFuncOrStmt elem { constructor, mandatory },
        FunctionBody next { constructor }
    }
};

node VarDec {
    children {
        Expr init { constructor } // Optional initialization
    },
    attributes {
        DefNodes type { constructor, mandatory },
        string name { constructor, mandatory }
    }
};

node Call {
    children {
        Expr expr,
        Exprs next { constructor }    
    },
    attributes {
        string name { constructor, mandatory } // Function name being called
    }
};


nodeset LocalFuncOrStmt = { Function, Assign, VarDec, Call };

node Function {
    children {
        // all the statements inside of the function
        FunctionBody body { constructor, mandatory }
    },
    attributes {
        // marks the decleration (Export, Extern, Local)
        Declaration declaration { constructor},
        // marks the function type as nodeset (Num, Float, Bool, Vector, Matrix or void)
        FunctionType type { constructor, mandatory},
        // the function name (main)
        string name { constructor, mandatory },
        // all the parameters inside the function parameters (Num, Float, Bool, Vector, Matrix)
        Parameters parameters { constructor }
    }
};

node ForStatement {
    children {
        // Code block
        Stmts stmts   
    },
    attributes {
        // int i = 0
        Assign assign { constructor, mandatory },
        
        // (i < 10)
        Exprs exprs { constructor, mandatory },

        // Optional increment step
        Expr step { constructor }
    }
};

node WhileStatement {
    children {
        // Code block
        Stmts stmts
    },
    attributes {
        // (i < 10)
        Exprs exprs { constructor, mandatory }
    }
};

node DoWhileStatement {
    children {
        // Code block
        Stmts stmts    
    },
    attributes {
        // (i < 10)
        Exprs exprs { constructor, mandatory }
    }
};

node ReturnStatement{
    attributes {
      DefNodes returnNode
    }
};

node IfStatement {
    children {
        // Code block
        Stmts stmts 
    },
    attributes {
        // If, Else if, Else
        IfType type,
        
        // (i = 10)
        Exprs exprs { constructor },
        
        // Next statement (else if[], else)
        IfStatement next { constructor }
    }
};

node Assign {
    children {
        VarLet let { constructor },
        Expr expr { constructor, mandatory }
    }
};

node Binop {
    children {
        Expr left { constructor, mandatory },
        Expr right { constructor, mandatory }
    },

    attributes {
        BinOpType op { constructor }
    }
};

nodeset Vars {
    nodes = {VarLet, Var},

    attributes {
        string name,
        Link decl
    }
};

node VarLet {
    attributes {
        string name { constructor }  // Repeat from nodeset to add constructor
    }
};

node Var {
    attributes {
        string name { constructor }
    }
};

node Num {
    attributes {
        int val { constructor }
    }
};

node Float {
    attributes {
        float val { constructor }
    }
};

node Bool {
    attributes {
        bool val { constructor }
    }
};

node Vector{
    attributes{
        ArrayType type,
        int length { constructor }
    }
};

node Matrix{
    attributes{
        ArrayType type,
        int colums { constructor },
        int rows { constructor }
    }
};

node Void {};

